package _2024_09_11;

public class TodayStudy {
    // Error 예상치못한 에러, 대응 불가능한 에러
    // Exception 대응 가능한 에러 -> 예외가 발생했을 때 상황에서 처리할 수 있는 코드작성

    // 예외처리 (throws, try-catch)
    // 시스템 장애를 막고, 예상치 못한 서비스의 종료를 막을 수 있음.
    // CheckedException 명시적으로 예외 처리를 강제화 (컴파일러가 빨간밑줄로 알려줌)
    // UnCheckedException 명시적으로 예외 처리를 강제화 하지 않음.
    // 에외가 발생하면 프로그램이 중단되고 오류 메시지를 보여줌
    //   -> 예외처리를 하면 프로그램의 중단없이 오류메시지를 출력하고 다음 프로세스로 넘어가도록 함.

    // try-catch-(finally) 예외를 직접 처리
    // 예외 발생 가능성이 있는 코드작성할 때
    // try {예외 발생 가능성 있는 코드} catch (예외코드 e) {예외가 발생 했을때 실행할 코드}
    // 예외가 발생하지 않고 정상적으로 실행되면 catch문 무시됨
    // try안에서 예외가 발생하면 나머지 코드 실행하지않고 catch문으로 감
    // finally는 try에서 예외가 발생하든 안하든 항상 실행함.
    // 자식예외클래스와 부모예외클래스가 둘다 사용되면 자식예외클래스 catch문을 제거해도 됨.
    // 자식예외클래스 catch문에서 따로 실행할 코드가 있을 때 작성
    // 다중 catch문에서 상위 예외클래스가 아래쪽에 위치해야 함. - 부모예외클래스가 위에있으면 자식예외클래스가 실행될 일이없음.

    // try-with-resource 자동 리소스 닫기
    // try (선언문) {} catch () {}
    // 리소스를 닫아야하는 코드(예, 변수.close();)가 있을때 사용하면 자동으로 닫아줌

    // throws 예외코드
    // 예외처리를 호출하는 쪽으로 떠넘김 (호출한 곳에서 해결해라) = 폭탄돌리기
    // 연쇄적으로 throws를 사용할 수 는 있지만 하지말자;
    // 바로 예외를 직접처리하는게 좋음.

    // throw 예외를 직접 발생시킬 때 사용
    // throw new 메소드명()
    // 예외 객체를 생성하고, 그것을 throws로 던져서 실행 흐름 전달

    // 사용자 정의 예외
    // 개발자가 특정 상황에 맞는 명확하고 의미있는 예외처리를 구현하기 위함
    // Exception(CheckedException) 또는 RunTimeException(UnCheckedException) 클래스를 상속받아 만듬
    // 예외메시지를 전달할 수 있도록 생성자 정의
    // throws와 throw를 사용하여 호출한 곳에서 이런 문제가 생길 수도 있다는 정보전달
    // 만드는 이유
    // 1. 상황에 맞는 의미 부여
    // 2. 가독성 향상
    // 3. 특정 비즈니스 로직에 맞는 예외처리
    // 4. 다양한 예외 상황에 대응
    // 5. 재사용성
}
